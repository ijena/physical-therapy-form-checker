<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FormCheck — Physical Therapy Form Checker</title>
<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,300&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0A0B0D;
    --surface: #111318;
    --surface-2: #191B22;
    --border: #2A2D38;
    --text: #E8E9ED;
    --text-dim: #7C7F8A;
    --accent: #4AE68A;
    --accent-glow: rgba(74, 230, 138, 0.15);
    --accent-dim: #2A8B52;
    --red: #E6564A;
    --red-glow: rgba(230, 86, 74, 0.2);
    --amber: #E6B84A;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: -40%;
    left: -20%;
    width: 80vw;
    height: 80vw;
    background: radial-gradient(circle, rgba(74,230,138,0.04) 0%, transparent 60%);
    pointer-events: none;
    z-index: 0;
  }

  nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 40px;
    backdrop-filter: blur(20px);
    background: rgba(10, 11, 13, 0.7);
    border-bottom: 1px solid var(--border);
  }

  .logo {
    font-family: 'Instrument Serif', serif;
    font-size: 1.5rem;
    letter-spacing: -0.02em;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .logo-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 12px var(--accent-glow);
  }

  .nav-links {
    display: flex;
    gap: 32px;
    list-style: none;
    font-size: 0.85rem;
    color: var(--text-dim);
  }

  .nav-links li { cursor: pointer; transition: color 0.2s; }
  .nav-links li:hover { color: var(--text); }

  main {
    position: relative;
    z-index: 1;
    max-width: 1200px;
    margin: 0 auto;
    padding: 120px 40px 60px;
  }

  .hero {
    text-align: center;
    margin-bottom: 60px;
    animation: fadeUp 0.8s ease-out;
  }

  .hero-badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 16px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 100px;
    font-size: 0.75rem;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 24px;
  }

  .hero-badge .pulse {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent);
    animation: pulse 2s infinite;
  }

  .hero h1 {
    font-family: 'Instrument Serif', serif;
    font-size: clamp(2.5rem, 5vw, 4rem);
    font-weight: 400;
    line-height: 1.1;
    letter-spacing: -0.03em;
    margin-bottom: 16px;
  }

  .hero h1 em {
    font-style: italic;
    color: var(--accent);
  }

  .hero p {
    font-size: 1.05rem;
    color: var(--text-dim);
    max-width: 560px;
    margin: 0 auto;
    line-height: 1.6;
  }

  .grid {
    display: grid;
    grid-template-columns: 1.4fr 1fr;
    gap: 20px;
    animation: fadeUp 0.8s ease-out 0.15s both;
  }

  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 28px;
    position: relative;
    overflow: hidden;
    transition: border-color 0.3s;
  }

  .card:hover { border-color: #3A3D48; }

  .card-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    margin-bottom: 20px;
  }

  .card-label svg { opacity: 0.5; }

  .video-card {
    grid-row: span 2;
    display: flex;
    flex-direction: column;
  }

  .video-container {
    flex: 1;
    position: relative;
    background: var(--bg);
    border-radius: 14px;
    overflow: hidden;
    min-height: 380px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border);
  }

  #cameraFeed {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
  }

  .video-placeholder {
    text-align: center;
    color: var(--text-dim);
  }

  .video-placeholder svg {
    width: 48px;
    height: 48px;
    opacity: 0.25;
    margin-bottom: 12px;
  }

  .video-placeholder p { font-size: 0.85rem; }

  .camera-overlay {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 12px;
    align-items: center;
    z-index: 5;
  }

  .camera-overlay.active { display: flex; }

  .recording-indicator {
    display: none;
    position: absolute;
    top: 16px;
    left: 16px;
    align-items: center;
    gap: 8px;
    background: rgba(230, 86, 74, 0.85);
    padding: 6px 14px;
    border-radius: 100px;
    font-size: 0.72rem;
    font-weight: 500;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    backdrop-filter: blur(10px);
    z-index: 5;
  }

  .recording-indicator.active { display: flex; }

  .rec-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: #fff;
    animation: pulse 1s infinite;
  }

  .timer {
    display: none;
    position: absolute;
    top: 16px;
    right: 16px;
    font-variant-numeric: tabular-nums;
    font-size: 0.85rem;
    background: rgba(0,0,0,0.5);
    padding: 6px 14px;
    border-radius: 100px;
    backdrop-filter: blur(10px);
    z-index: 5;
  }

  .timer.active { display: block; }

  /* Countdown overlay */
  .countdown-overlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;

    font-family: 'DM Sans', sans-serif;
    font-size: clamp(72px, 10vw, 140px);
    font-weight: 700;
    color: #fff;
    text-shadow: 0 12px 35px rgba(0,0,0,0.6);

    background: rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(2px);
  }

  .countdown-overlay.active { display: flex; }
  .countdown-overlay.pop { animation: pop 0.35s ease-out; }

  @keyframes pop {
    0%   { transform: scale(0.85); opacity: 0; }
    45%  { transform: scale(1.1);  opacity: 1; }
    100% { transform: scale(1.0);  opacity: 1; }
  }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    border: none;
    border-radius: 12px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.25s;
    padding: 12px 24px;
    white-space: nowrap;
  }

  .btn svg { flex-shrink: 0; }

  .btn-primary { background: var(--accent); color: var(--bg); }
  .btn-primary:hover { background: #5CF098; box-shadow: 0 0 30px var(--accent-glow); }

  .btn-danger { background: var(--red); color: #fff; }
  .btn-danger:hover { box-shadow: 0 0 30px var(--red-glow); }

  .btn-ghost {
    background: var(--surface-2);
    color: var(--text);
    border: 1px solid var(--border);
  }

  .btn-ghost:hover { border-color: #4A4D58; }

  .btn-icon {
    width: 46px;
    height: 46px;
    padding: 0;
    border-radius: 50%;
  }

  .video-actions {
    display: flex;
    gap: 10px;
    margin-top: 16px;
  }

  .mic-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    padding: 10px 0;
  }

  .mic-btn {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: var(--surface-2);
    border: 2px solid var(--border);
    color: var(--text-dim);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
  }

  .mic-btn:hover { border-color: var(--accent); color: var(--accent); }

  .mic-btn.listening {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 0 8px var(--accent-glow);
    animation: micPulse 1.5s ease-in-out infinite;
  }

  .mic-status {
    font-size: 0.8rem;
    color: var(--text-dim);
    min-height: 1.2em;
  }

  .mic-status.active { color: var(--accent); }

  .transcript-box {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 20px;
    min-height: 100px;
    font-size: 0.9rem;
    line-height: 1.7;
    color: var(--text);
    position: relative;
  }

  .transcript-empty {
    color: var(--text-dim);
    font-style: italic;
    font-size: 0.85rem;
  }

  .transcript-text .interim {
    color: var(--text-dim);
    border-right: 2px solid var(--accent);
    padding-right: 2px;
    animation: blink 0.8s step-end infinite;
  }

  .exercise-detected {
    display: none;
    margin-top: 16px;
    padding: 14px 18px;
    background: var(--accent-glow);
    border: 1px solid var(--accent-dim);
    border-radius: 12px;
    font-size: 0.85rem;
  }

  .exercise-detected.active { display: flex; align-items: center; gap: 10px; }

  .exercise-name {
    font-weight: 600;
    color: var(--accent);
  }

  .status-bar {
    margin-top: 20px;
    display: flex;
    align-items: center;
    gap: 24px;
    padding: 16px 24px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    font-size: 0.8rem;
    color: var(--text-dim);
    animation: fadeUp 0.8s ease-out 0.3s both;
  }

  .status-item { display: flex; align-items: center; gap: 8px; }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--border);
    transition: background 0.3s, box-shadow 0.3s;
  }

  .status-dot.on { background: var(--accent); box-shadow: 0 0 8px var(--accent-glow); }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  @keyframes micPulse {
    0%, 100% { box-shadow: 0 0 0 8px var(--accent-glow); }
    50% { box-shadow: 0 0 0 16px rgba(74,230,138,0.06); }
  }

  @keyframes blink { 50% { border-color: transparent; } }

  @media (max-width: 768px) {
    nav { padding: 16px 20px; }
    main { padding: 100px 20px 40px; }
    .grid { grid-template-columns: 1fr; }
    .video-card { grid-row: span 1; }
    .video-container { min-height: 280px; }
    .nav-links { display: none; }
  }
</style>
</head>

<body>
<nav>
  <div class="logo">
    <span class="logo-dot"></span>
    FormCheck
  </div>
  <ul class="nav-links">
    <li>Home</li>
    <li>Exercises</li>
    <li>History</li>
    <li>Settings</li>
  </ul>
</nav>

<main>
  <section class="hero">
    <div class="hero-badge"><span class="pulse"></span> AI-Powered Analysis</div>
    <h1>Perfect your <em>form</em>,<br>prevent injury</h1>
    <p>
      Record yourself performing exercises and get real-time form feedback.
      Voice commands: “start camera”, “start recording”, “record again”, “stop listening”.
    </p>
  </section>

  <div class="grid">
    <!-- VIDEO CARD -->
    <div class="card video-card">
      <div class="card-label">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
        Camera Feed
      </div>

      <div class="video-container">
        <video id="cameraFeed" autoplay muted playsinline></video>

        <div class="video-placeholder" id="videoPlaceholder">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
          <p>Camera feed will appear here</p>
        </div>

        <div class="recording-indicator" id="recIndicator">
          <span class="rec-dot"></span> REC
        </div>

        <div class="timer" id="timer">00:00</div>

        <div class="countdown-overlay" id="countdownOverlay"></div>

        <div class="camera-overlay" id="cameraOverlay">
          <button class="btn btn-danger btn-icon" id="btnRecord" title="Start/Stop Recording" onclick="toggleRecording()">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="7"/></svg>
          </button>
        </div>
      </div>

      <div class="video-actions">
        <button class="btn btn-primary" id="btnStartCamera" onclick="toggleCamera()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
          Start Camera
        </button>

        <button class="btn btn-ghost" id="btnFlip" onclick="flipCamera()" style="display:none">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6"/><path d="M23 20v-6h-6"/><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/></svg>
          Flip
        </button>

        <button class="btn btn-ghost" id="btnRecordAgain" onclick="recordAgainAndStart()" style="display:none">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 4v6h6"/><path d="M23 20v-6h-6"/>
            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10"/>
            <path d="M22 14l-4.64 4.36A9 9 0 0 1 3.51 15"/>
          </svg>
          Record Again
        </button>
      </div>
    </div>

    <!-- VOICE CARD -->
    <div class="card voice-card">
      <div class="card-label">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
        Voice Command
      </div>

      <div class="mic-area">
        <button class="mic-btn" id="micBtn" onclick="toggleMic()">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
        </button>
        <span class="mic-status" id="micStatus">Tap to start listening</span>
      </div>

      <p style="font-size:0.78rem;color:var(--text-dim);text-align:center;margin-top:8px;">
        Try: <span style="color:var(--text);">"record again"</span> or <span style="color:var(--text);">"start recording again"</span>
      </p>
    </div>

    <!-- TRANSCRIPT CARD -->
    <div class="card transcript-card">
      <div class="card-label">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
        Speech Transcript
      </div>

      <div class="transcript-box" id="transcriptBox">
        <span class="transcript-empty" id="transcriptEmpty">Your speech will appear here in real time…</span>
        <span class="transcript-text" id="transcriptText"></span>
      </div>

      <div class="exercise-detected" id="exerciseDetected">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
        <span>Exercise detected: <span class="exercise-name" id="exerciseName"></span></span>
      </div>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item"><span class="status-dot" id="statusCamera"></span>Camera</div>
    <div class="status-item"><span class="status-dot" id="statusMic"></span>Microphone</div>
    <div class="status-item"><span class="status-dot" id="statusRec"></span>Recording</div>
  </div>
</main>

<script>
  // ===== STATE =====
  let cameraStream = null;
  let isRecording = false;
  let mediaRecorder = null;
  let recordedChunks = [];
  let timerInterval = null;
  let seconds = 0;

  let isListening = false;
  let recognition = null;
  let finalTranscript = '';
  let facingMode = 'user';

  // App-level state
  let appState = {
    exercise: null,
    cameraOn: false,
    recordingOn: false,
  };

  // ===== ACTION SURFACE =====
  const ACTIONS = {
    SET_EXERCISE: "set_exercise",
    START_CAMERA: "start_camera",
    STOP_CAMERA: "stop_camera",
    START_RECORDING: "start_recording",
    STOP_RECORDING: "stop_recording",
    RECORD_AGAIN: "record_again",
    RESET_TRANSCRIPT: "reset_transcript",
    STOP_LISTENING: "stop_listening",
    SPEAK: "speak",
  };

  // ===== KNOWN EXERCISES =====
  const exercises = [
    'squat', 'squats', 'lunge', 'lunges', 'deadlift', 'deadlifts',
    'shoulder press', 'overhead press', 'push up', 'push ups', 'pushup', 'pushups',
    'plank', 'bicep curl', 'bicep curls', 'tricep extension', 'lateral raise',
    'leg press', 'hip thrust', 'glute bridge', 'calf raise', 'calf raises',
    'hamstring curl', 'leg extension', 'wall sit', 'sit up', 'sit ups',
    'crunch', 'crunches', 'bird dog', 'clamshell', 'step up', 'step ups',
    'romanian deadlift', 'rdl', 'band pull apart', 'face pull',
    'knee extension', 'straight leg raise', 'heel slide', 'ankle pump',
    'quad set', 'bridge', 'bridges', 'side lying hip abduction'
  ];

  // ===== CAMERA =====
  async function toggleCamera() {
    const btn = document.getElementById('btnStartCamera');
    const video = document.getElementById('cameraFeed');
    const placeholder = document.getElementById('videoPlaceholder');
    const overlay = document.getElementById('cameraOverlay');
    const flipBtn = document.getElementById('btnFlip');
    const statusDot = document.getElementById('statusCamera');
    const recordAgainBtn = document.getElementById('btnRecordAgain');

    if (cameraStream) {
      // cleanup preview url if any
      if (window.lastRecordingUrl) {
        URL.revokeObjectURL(window.lastRecordingUrl);
        window.lastRecordingUrl = null;
      }
      window.lastRecordingBlob = null;

      cameraStream.getTracks().forEach(t => t.stop());
      cameraStream = null;
      appState.cameraOn = false;

      video.style.display = 'none';
      placeholder.style.display = '';
      overlay.classList.remove('active');
      flipBtn.style.display = 'none';
      recordAgainBtn.style.display = 'none';

      btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg> Start Camera`;
      statusDot.classList.remove('on');

      if (isRecording) stopRecordingUI();
      return;
    }

    try {
      cameraStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });

      appState.cameraOn = true;

      video.srcObject = cameraStream;
      video.controls = false;
      video.loop = false;
      video.muted = true;
      video.playsInline = true;
      video.style.display = 'block';
      placeholder.style.display = 'none';
      overlay.classList.add('active');
      flipBtn.style.display = '';
      recordAgainBtn.style.display = 'none';

      btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg> Stop Camera`;
      statusDot.classList.add('on');

      video.play().catch(() => {});
    } catch (err) {
      alert('Could not access camera. Please allow camera permissions.');
    }
  }

  async function flipCamera() {
    facingMode = facingMode === 'user' ? 'environment' : 'user';
    if (cameraStream) {
      cameraStream.getTracks().forEach(t => t.stop());
      cameraStream = null;
      appState.cameraOn = false;
      await toggleCamera();
    }
  }

  // ===== COUNTDOWN =====
  function startCountdown(secondsToCount = 3) {
    const overlay = document.getElementById('countdownOverlay');
    const recIndicator = document.getElementById('recIndicator');

    recIndicator.classList.remove('active');
    overlay.classList.add('active');

    return new Promise((resolve) => {
      let remaining = secondsToCount;

      const tick = () => {
        overlay.textContent = remaining;

        overlay.classList.remove('pop');
        void overlay.offsetWidth;
        overlay.classList.add('pop');

        if (remaining === 1) {
          setTimeout(() => {
            overlay.classList.remove('active');
            overlay.classList.remove('pop');
            overlay.textContent = '';
            resolve();
          }, 1000);
          return;
        }

        remaining--;
        setTimeout(tick, 1000);
      };

      tick();
    });
  }

  // ===== RECORDING =====
  async function toggleRecording() {
    const btn = document.getElementById('btnRecord');
    const indicator = document.getElementById('recIndicator');
    const timerEl = document.getElementById('timer');
    const statusDot = document.getElementById('statusRec');

    if (!cameraStream) return;

    // STOP
    if (isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      appState.recordingOn = false;

      clearInterval(timerInterval);

      btn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="7"/></svg>`;
      indicator.classList.remove('active');
      timerEl.classList.remove('active');
      statusDot.classList.remove('on');
      return;
    }

    switchToLivePreview();

    // START (countdown first)
    btn.disabled = true;
    await startCountdown(3);
    btn.disabled = false;

    recordedChunks = [];

    try {
      mediaRecorder = new MediaRecorder(cameraStream, { mimeType: 'video/webm' });
    } catch {
      mediaRecorder = new MediaRecorder(cameraStream);
    }

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      const video = document.getElementById('cameraFeed');
      const overlay = document.getElementById('cameraOverlay');
      const recordAgainBtn = document.getElementById('btnRecordAgain');

      if (window.lastRecordingUrl) URL.revokeObjectURL(window.lastRecordingUrl);

      const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
      const url = URL.createObjectURL(blob);

      video.srcObject = null;
      video.src = url;
      video.controls = true;
      video.loop = true;
      video.muted = true;
      video.playsInline = true;

      video.play().catch(() => {});

      window.lastRecordingBlob = blob;
      window.lastRecordingUrl = url;

      overlay.classList.remove('active');
      recordAgainBtn.style.display = 'inline-flex';
    };

    mediaRecorder.start();
    isRecording = true;
    appState.recordingOn = true;

    seconds = 0;
    updateTimer();
    timerInterval = setInterval(() => {
      seconds++;
      updateTimer();
    }, 1000);

    btn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>`;
    indicator.classList.add('active');
    timerEl.classList.add('active');
    statusDot.classList.add('on');
  }

  function stopRecordingUI() {
    const btn = document.getElementById('btnRecord');
    const indicator = document.getElementById('recIndicator');
    const timerEl = document.getElementById('timer');
    const statusDot = document.getElementById('statusRec');

    isRecording = false;
    appState.recordingOn = false;
    clearInterval(timerInterval);

    btn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="7"/></svg>`;
    indicator.classList.remove('active');
    timerEl.classList.remove('active');
    statusDot.classList.remove('on');
  }

  function recordAgain() {
    const video = document.getElementById('cameraFeed');
    const overlay = document.getElementById('cameraOverlay');
    const recordAgainBtn = document.getElementById('btnRecordAgain');

    if (!cameraStream) return;

    if (window.lastRecordingUrl) {
      URL.revokeObjectURL(window.lastRecordingUrl);
      window.lastRecordingUrl = null;
    }
    window.lastRecordingBlob = null;

    video.pause();
    video.removeAttribute('src');
    video.load();

    switchToLivePreview();

    overlay.classList.add('active');
    recordAgainBtn.style.display = 'none';

    video.play().catch(() => {});
  }

  async function recordAgainAndStart() {
    if (!cameraStream) return;

    if (isRecording) {
      await toggleRecording(); // stop
      await new Promise(r => setTimeout(r, 150));
    }

    recordAgain();
    await new Promise(r => requestAnimationFrame(() => r()));
    toggleRecording();
  }

  function updateTimer() {
    const m = String(Math.floor(seconds / 60)).padStart(2, '0');
    const s = String(seconds % 60).padStart(2, '0');
    document.getElementById('timer').textContent = `${m}:${s}`;
  }

  function switchToLivePreview() {
    const video = document.getElementById('cameraFeed');
    if (!cameraStream) return;

    if (window.lastRecordingUrl) {
      URL.revokeObjectURL(window.lastRecordingUrl);
      window.lastRecordingUrl = null;
    }
    window.lastRecordingBlob = null;

    video.pause();
    video.removeAttribute('src');
    video.load();

    video.controls = false;
    video.srcObject = cameraStream;
    video.muted = true;
    video.playsInline = true;
    video.play().catch(() => {});
  }

  // ===== SPEECH RECOGNITION =====
  function initSpeechRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) return null;

    const recog = new SpeechRecognition();
    recog.continuous = true;
    recog.interimResults = true;
    recog.lang = 'en-US';

    recog.onresult = (event) => {
      let interim = '';
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const t = event.results[i][0].transcript;

        if (event.results[i].isFinal) {
          finalTranscript += t + ' ';
          handleFinalUtterance(t);
        } else {
          interim += t;
        }
      }
      updateTranscript(finalTranscript, interim);
    };

    recog.onerror = (event) => {
      if (event.error === 'no-speech') return;
      console.error('Speech error:', event.error);
    };

    recog.onend = () => {
      if (isListening) recog.start();
    };

    return recog;
  }

  function toggleMic() {
    const micBtn = document.getElementById('micBtn');
    const micStatus = document.getElementById('micStatus');
    const statusDot = document.getElementById('statusMic');

    if (!recognition) {
      recognition = initSpeechRecognition();
      if (!recognition) {
        alert('Speech recognition is not supported in this browser. Try Chrome.');
        return;
      }
    }

    if (!isListening) {
      recognition.start();
      isListening = true;
      micBtn.classList.add('listening');
      micStatus.textContent = 'Listening…';
      micStatus.classList.add('active');
      statusDot.classList.add('on');
    } else {
      isListening = false;
      recognition.stop();
      micBtn.classList.remove('listening');
      micStatus.textContent = 'Tap to start listening';
      micStatus.classList.remove('active');
      statusDot.classList.remove('on');
    }
  }

  function stopListening() {
    const micBtn = document.getElementById('micBtn');
    const micStatus = document.getElementById('micStatus');
    const statusDot = document.getElementById('statusMic');

    if (!recognition || !isListening) return;

    isListening = false;
    recognition.stop();

    micBtn.classList.remove('listening');
    micStatus.textContent = 'Tap to start listening';
    micStatus.classList.remove('active');
    statusDot.classList.remove('on');
  }

  function updateTranscript(final, interim) {
    const textEl = document.getElementById('transcriptText');
    const emptyEl = document.getElementById('transcriptEmpty');
    emptyEl.style.display = (final || interim) ? 'none' : '';
    textEl.innerHTML = final + (interim ? `<span class="interim">${interim}</span>` : '');
  }

  // ===== VOICE COMMAND ROUTER =====
  function handleFinalUtterance(text) {
    const u = text.toLowerCase().trim();

    if (u.includes("stop listening")) {
      return runActions([
        { type: ACTIONS.SPEAK, text: "Okay. Stopping listening." },
        { type: ACTIONS.STOP_LISTENING }
      ]);
    }

    if (u.includes("start camera")) {
      return runActions([
        { type: ACTIONS.START_CAMERA },
        { type: ACTIONS.SPEAK, text: "Starting camera." }
      ]);
    }

    if (u.includes("stop camera")) {
      return runActions([
        { type: ACTIONS.STOP_CAMERA },
        { type: ACTIONS.SPEAK, text: "Stopping camera." }
      ]);
    }

    // ✅ NEW: record again voice command
    if (u.includes("record again") || u.includes("start recording again") || u.includes("redo")) {
      return runActions([
        { type: ACTIONS.RECORD_AGAIN },
        { type: ACTIONS.SPEAK, text: "Okay. Recording again." }
      ]);
    }

    if (u.includes("start recording") || u === "record" || u.includes("record video")) {
      return runActions([
        { type: ACTIONS.START_RECORDING },
        { type: ACTIONS.SPEAK, text: "Starting recording." }
      ]);
    }

    if (u.includes("stop recording") || u === "stop") {
      return runActions([
        { type: ACTIONS.STOP_RECORDING },
        { type: ACTIONS.SPEAK, text: "Recording stopped." }
      ]);
    }

    if (u.includes("reset transcript") || u.includes("clear transcript")) {
      finalTranscript = "";
      updateTranscript("", "");
      return runActions([{ type: ACTIONS.SPEAK, text: "Transcript cleared." }]);
    }

    const ex = findExercise(u);
    if (ex) {
      appState.exercise = ex;
      return runActions([
        { type: ACTIONS.SET_EXERCISE, exercise: ex },
        { type: ACTIONS.SPEAK, text: `Okay. ${prettyExercise(ex)} selected.` }
      ]);
    }
  }

  function findExercise(utterance) {
    for (const ex of exercises) {
      if (utterance.includes(ex)) return ex;
    }
    return null;
  }

  function prettyExercise(ex) {
    return ex.split(" ").map(w => w ? (w[0].toUpperCase() + w.slice(1)) : w).join(" ");
  }

  function runActions(actions) {
    for (const a of actions) {
      switch (a.type) {
        case ACTIONS.SET_EXERCISE: {
          const detected = document.getElementById('exerciseDetected');
          const name = document.getElementById('exerciseName');
          name.textContent = prettyExercise(a.exercise);
          detected.classList.add('active');
          break;
        }
        case ACTIONS.START_CAMERA: {
          if (!cameraStream) toggleCamera();
          break;
        }
        case ACTIONS.STOP_CAMERA: {
          if (cameraStream) toggleCamera();
          break;
        }
        case ACTIONS.START_RECORDING: {
          if (cameraStream && !isRecording) toggleRecording();
          break;
        }
        case ACTIONS.STOP_RECORDING: {
          if (isRecording) toggleRecording();
          break;
        }
        case ACTIONS.RECORD_AGAIN: {
          recordAgainAndStart();
          break;
        }
        case ACTIONS.STOP_LISTENING: {
          stopListening();
          break;
        }
        case ACTIONS.SPEAK: {
          speak(a.text);
          break;
        }
      }
    }
  }

  // ===== TTS =====
  function speak(text) {
    if (!("speechSynthesis" in window)) return;
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 1.0;
    u.pitch = 1.0;
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(u);
  }
</script>
<script type="module" src="./app.js"></script>
</body>
</html>